# Test JSON payload to simulate Kafka events
producer.mock.body= {"user":"${exchangeProperty.CamelTimerName}","text":"message ${exchangeProperty.CamelTimerCounter}"}

# Time the aggregator will wait for messages before the data storage process is triggered
message.aggregator.timeout = 20000

# Cut-off time the controller uses to allow messages to be aggregated.
# Messages arriving after cut-off time will be aggregated in the next cron run
# Attention: cut-off time should be less than aggregator timeout
messege.controller.cutoff.time = 15000

# AMQ Strams connectivity
# camel.uri.kafka.parameters=\
# brokers=my-cluster-kafka-bootstrap:9092\
# &clientId=lab\
# &groupId=lab\
# &autoOffsetReset=earliest\
# &autoCommitEnable=false\
# &allowManualCommit=true

kafka.topic=myroom
# camel.uri.kafka.parameters=\
# camel.components.kafka.brokers=my-cluster-kafka-bootstrap:9092
camel.component.kafka.clientId=lab
camel.component.kafka.groupId=lab
camel.component.kafka.autoOffsetReset=earliest
camel.component.kafka.autoCommitEnable=false
camel.component.kafka.allowManualCommit=true


# S3 connectivity
camel.uri.s3.parameters=\
accessKey=YOUR_ACCESS_KEY\
&secretKey=RAW(YOUR_SECRET_KEY)\
&region=us-east-1\
&uriEndpointOverride=http://s3.openshift-storage.svc:80\
&overrideEndpoint=true\
&useDefaultCredentialsProvider=false\
&autoCreateBucket=true

camel.main.duration-max-idle-seconds=5
quarkus.openshift.deployment-kind=cron-job
quarkus.openshift.cron-job.schedule=0/1 * * * ?
quarkus.openshift.prometheus.generate-service-monitor=false
quarkus.openshift.labels.app.openshift.io/runtime=camel